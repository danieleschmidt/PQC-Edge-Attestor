/**
 * @file dilithium.h
 * @brief Dilithium-5 post-quantum digital signature interface
 * 
 * This header defines the API for the Dilithium-5 implementation, providing
 * quantum-resistant digital signatures for IoT edge devices.
 */

#ifndef DILITHIUM_H
#define DILITHIUM_H

#include "pqc_common.h"
#include <stdint.h>
#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

// Dilithium-5 algorithm parameters
#define DILITHIUM_PUBLICKEYBYTES  2592  /**< Public key size in bytes */
#define DILITHIUM_SECRETKEYBYTES  4864  /**< Secret key size in bytes */
#define DILITHIUM_SIGNATUREBYTES  4595  /**< Maximum signature size in bytes */

// Internal constants  
#define DILITHIUM_SYMBYTES        32    /**< Size of hashes and seeds */
#define DILITHIUM_QINV            58728449  /**< q^(-1) mod 2^32 */

/**
 * @brief Dilithium public key structure
 */
typedef struct {
    uint8_t rho[32];                               /**< Public seed for matrix A */
    uint8_t t1[DILITHIUM_PUBLICKEYBYTES - 32];    /**< Packed high bits of t */
} dilithium_public_key_t;

/**
 * @brief Dilithium secret key structure
 */
typedef struct {
    uint8_t rho[32];                    /**< Public seed for matrix A */
    uint8_t key[32];                    /**< Private random seed */
    uint8_t tr[64];                     /**< Hash of public key */
    uint32_t s1[7 * 256];              /**< Secret polynomial s1 */
    uint32_t s2[8 * 256];              /**< Secret polynomial s2 */
    uint32_t t0[8 * 256];              /**< Low bits of t */
} dilithium_secret_key_t;

/**
 * @brief Dilithium signature structure
 */
typedef struct {
    uint8_t challenge[32];              /**< Challenge hash c */
    uint32_t response[7 * 256];         /**< Response polynomial z */
    uint8_t hint[80];                   /**< Hint vector h */
} dilithium_signature_t;

/**
 * @brief Dilithium keypair structure for convenience
 */
typedef struct {
    dilithium_public_key_t pk;          /**< Public key */
    dilithium_secret_key_t sk;          /**< Secret key */
} dilithium_keypair_t;

/**
 * @brief Generate a Dilithium-5 keypair
 * 
 * This function generates a new Dilithium-5 keypair suitable for digital signatures.
 * The implementation uses cryptographically secure random number generation and
 * follows NIST specification for parameter generation.
 * 
 * @param[out] pk Generated public key
 * @param[out] sk Generated secret key
 * @return PQC_SUCCESS on success, error code on failure
 * 
 * @note This function is not constant-time in key generation.
 * @note The secret key includes derived values for efficient signing.
 */
pqc_result_t dilithium_keypair(dilithium_public_key_t *pk, dilithium_secret_key_t *sk);

/**
 * @brief Sign a message using Dilithium-5
 * 
 * This function generates a digital signature for the provided message using
 * the secret key. The signature provides existential unforgeability under
 * chosen message attacks (EUF-CMA) in the quantum random oracle model.
 * 
 * @param[out] signature Generated signature buffer
 * @param[out] siglen Length of generated signature
 * @param[in] message Message to sign
 * @param[in] msglen Length of message
 * @param[in] sk Secret key for signing
 * @return PQC_SUCCESS on success, error code on failure
 * 
 * @note This function uses rejection sampling and may require multiple iterations.
 * @note The signature length is variable but bounded by DILITHIUM_SIGNATUREBYTES.
 */
pqc_result_t dilithium_sign(uint8_t *signature, size_t *siglen,
                           const uint8_t *message, size_t msglen,
                           const dilithium_secret_key_t *sk);

/**
 * @brief Verify a Dilithium-5 signature
 * 
 * This function verifies that a signature was generated by the holder of
 * the secret key corresponding to the provided public key. Verification
 * is deterministic and constant-time.
 * 
 * @param[in] signature Signature to verify
 * @param[in] siglen Length of signature
 * @param[in] message Original message
 * @param[in] msglen Length of message
 * @param[in] pk Public key for verification
 * @return PQC_SUCCESS if signature is valid, error code if invalid
 * 
 * @note This function is constant-time to prevent timing attacks.
 * @note Invalid signatures are rejected without revealing the reason.
 */
pqc_result_t dilithium_verify(const uint8_t *signature, size_t siglen,
                             const uint8_t *message, size_t msglen,
                             const dilithium_public_key_t *pk);

/**
 * @brief Validate Dilithium public key format
 * 
 * This function performs basic validation of a Dilithium public key to ensure
 * it has the correct format and polynomial coefficients are properly reduced.
 * 
 * @param[in] pk Public key to validate
 * @return PQC_SUCCESS if valid, error code if invalid
 */
pqc_result_t dilithium_validate_public_key(const dilithium_public_key_t *pk);

/**
 * @brief Validate Dilithium signature format
 * 
 * This function performs basic validation of a Dilithium signature to ensure
 * it has the correct format and polynomial coefficients are within valid ranges.
 * 
 * @param[in] signature Signature to validate
 * @param[in] siglen Length of signature
 * @return PQC_SUCCESS if valid, error code if invalid
 */
pqc_result_t dilithium_validate_signature(const uint8_t *signature, size_t siglen);

/**
 * @brief Get algorithm information
 * 
 * @return Pointer to algorithm info structure
 */
const pqc_algorithm_info_t* dilithium_get_algorithm_info(void);

// Internal functions for testing and debugging (not part of public API)
#ifdef PQC_ENABLE_TESTING
void dilithium_poly_ntt(uint32_t poly[256]);
void dilithium_poly_invntt(uint32_t poly[256]);
uint32_t dilithium_montgomery_reduce(uint64_t a);
uint32_t dilithium_reduce32(uint32_t a);
void dilithium_power2round(uint32_t *a1, uint32_t *a0, uint32_t a);
void dilithium_decompose(uint32_t *a1, uint32_t *a0, uint32_t a);
int dilithium_make_hint(uint32_t a0, uint32_t a1);
uint32_t dilithium_use_hint(uint32_t a, int hint);
#endif

#ifdef __cplusplus
}
#endif

#endif /* DILITHIUM_H */